<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
</head>
<body>
<div id="display"></div>
</body>
<script>

class UIElement {
  constructor(div, label) {
    this.children = [];

    if (div) {
      if (typeof div == 'string') {
        this.setDiv(document.getElementById(div));
      } else {
        this.setDiv(div);
      }
    } else {
      this.setDiv(document.createElement('div'));
    }

    // Helper to generate div wrappers
    const divWrap = (element, style) => {
      const wrapperDiv = document.createElement('div');
      wrapperDiv.append(element);
      Object.assign(wrapperDiv.style, style);
      return wrapperDiv;
    }

    // Let's have a div to wrap our own content
    this.headerDiv = document.createElement('div');
    this.headerDiv.style.position = 'relative';
    this.getDiv().append(this.headerDiv);

    // Let's show a label, if present
    this.labelP = document.createElement('p');
    Object.assign(this.labelP.style, {
      'font-size': '8pt',
      color: '#888888',
      position: 'absolute',
      // border: '1px red solid',
      top: '-2.5em',
      width: '20em',
    });
    this.headerDiv.append(this.labelP);
    if (label) {
      this.setLabel(label);
    }

    // Have a text value in addition to other possible children
    this.p = document.createElement('p');
    this.headerDiv.append(this.p);

    // Let's also have a div to wrap our children
    this.setChildrenDiv(document.createElement('div'));
    this.getChildrenDiv().style.position = 'relative';
    this.addDiv(this.getChildrenDiv());

    // To actually evaluate placements we may need some context.
    // I guess we can introspect our own bounding box.
    // We can also track changes of our children's properties, and
    // recompute layouts and/or notify children of the need to recompute.
    this.getDiv().style.position = 'absolute';
    this.getDiv().style.border = '1px #bbbbbb dotted';

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    // For now, establish conventions by defining some of our parameters here.
    this.conventions = {
      // gravityDirection: 'left',
    };
    // So far we have for each UIElement:
    // label, text, children
    // We will likely be adding more properties.
    // Think about how we want to support this: what kinds of properties do we need; what is the desired workflow for
    // adding them; how can we import/export elements (save/load, serialize/deserialize, marshall/unmarshall);
    // rendering; evaluating; referencing; indexing; etc.
    this.properties = {
      children: [],
      label: null,
      text: null,
      layoutProperties: null, // member of split group; position; etc.
    };
  }

  getChildrenDiv() {
    return this.childrenDiv;
  }

  setChildrenDiv(div) {
    this.childrenDiv = div;
  }

  getDiv() {
    return this.div;
  }

  setDiv(div) {
    this.div = div;
  }

  addDiv(div) {
    this.getDiv().append(div);
  }

  setText(text) {
    // Apply the update to the docElement
    this.p.innerText = text;
  }

  getText() {
    return this.p.innerText;
  }

  getLabel() {
    return this.label;
  }

  setLabel(label) {
    this.label = label;
    this.labelP.innerText = this.getLabel();
  }

  expandToWindow() {
    const margin = 50;
    this.getDiv().style.width = (window.innerWidth - 2 * margin) + 'px';
    this.getDiv().style.height = (window.innerHeight - 2 * margin) + 'px';
    this.getDiv().style.left = margin + 'px';
    this.getDiv().style.top = margin + 'px';
  }

  createChild() {
    // We want to return a handle like our own, but
    // initialized with the child as the root.
    // For now, the child will have no access to the parent;
    // it will be a one-way relationship.
    const child = new UIElement();
    child.getDiv().style.position = 'absolute';
    this.children.push(child);
    // Need to tie the DOM together as well
    this.getChildrenDiv().append(child.getDiv());
    return child;
  }

  createChildren(infoArray, configureChild) {
    // For now, let's just enforce here that each UIElement can only have one set of children.
    if (this.children.length > 0) {
      throw new Error('Each UIElement may only have one set of children');
    }
    return infoArray.map((info, index) => {
      return this.createChild();
    }).map((child, index, children) => {
      configureChild(child, index, children);
      return child;
    });
  }

  verticalSplit(infoArray) {
    let offset = 0;
    return this.createChildren(infoArray, (child, index, children) => {
      // We want this child to start where its predecessor ends
      child.getDiv().style.top = offset + 'px';
      child.getDiv().style.height = infoArray[index];
      child.getDiv().style.width = '100%';
      child.setLabel(`verticalSplit ${index}`);
      offset += child.getDiv().offsetHeight;
    });
  }

  horizontalSplit(infoArray) {
    let offset = 0;
    return this.createChildren(infoArray, (child, index, children) => {
      child.getDiv().style.left = offset + 'px';
      child.getDiv().style.width = infoArray[index];
      child.setLabel(`horizontalSplit ${index}`);
      offset += child.getDiv().offsetWidth;
    });
  }
}

// Example
const webPage = new UIElement('display', 'main');
webPage.expandToWindow();
const [titleBar, body] = webPage.verticalSplit(['10em', undefined]);
const columns = body.horizontalSplit(['30em', '30em', undefined]);
const rows2 = columns[1].verticalSplit(['20em', undefined]);

titleBar.setText('Title Bar');
body.setText('Body');
columns.map((col, idx) => {
  col.setText(`Column ${idx + 1}`);
});
rows2.map((row, idx) => {
  row.setText(`Column 2, Row ${idx + 1}`);
});

setTimeout(() => {
  body.setText(body.getText() + ' ...Hello!');
}, 2000);



// Let's support a grid layout system...
// That can be done by creating horizontal and vertical subdivisions, right?

// Also there are a couple more considerations to make for these UIElement boxes.
// How big do we want them?
// Not just shrinking to fit contents

// How do we want to handle interactions among elements?
// What we have so far is this kind of top-down hierarchical model of parents and children, forming a tree of elements.
// This forces us to integrate each concept with its neighbors from the top down.
// What if we implement a protocol by which each element can negotiate with its neighbors?
// In cases where there is ambiguity, perhaps solicit input from a user.

// Let's consider doing this using a dialog among elements.
// Each one maintains some state (or references thereto?)
// Each one seeks to be aware of the considerations of the others.

// 2 extremes -- full centralization or full decentralization. What about options in between?
// We could have special a special kind of entity that carries the responsibility of understanding the considerations of
// the others, and has none of its own that directly interfere with theirs. A manager node. But when more than one of
// these operate in the same space they'll need to coordinate, so we haven't really solved the problem.

// Ultimately I want the viewport to be in the hands of the user. It needs to be under their discretion.

// Each entity can report its own considerations.

// In this immediate application, what we're trying to manage is the allocation of viewport space.
// Based on what? Well, based on content expressed through the provided API. So far, that is the following:
// UIElement
// - constructor(div, label) : UIElement
// - createChild() : UIElement
// - createChildren() : []UIElement
// - verticalSplit([]rowsInfo) : []UIElement
// - horizontalSplit([]colsInfo) : []UIElement
// - expandToWindow() : void
// - getLabel(), setLabel()
// - getText(), setText()
// - getDiv(), setDiv()
// - addDiv()

// Parents keep a list of their children.
// We create corresponding DOM elements for each of our elements.
// We can access all the DOM functionality through the DOM element,
// exposed via getDiv().

// So what do we have? An entity with properties 'label' and 'text';
// it can have any number of children, but must choose a single method for doing so.
// Current choice is between 'vertical split' and 'horizontal split'.
// In either case, the size and number of splits is arbitrary.



</script>



