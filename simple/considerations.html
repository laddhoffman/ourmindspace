<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<script src="./uielement.js"></script>
<script src="./transport.js"></script>
<script src="./json-logic.js"></script>
<script src="./uuid.js"></script>
<script src="./store.js"></script>
<script src="./debug.js"></script>
<script src="./rectangle.js"></script>
<link rel="stylesheet" type="text/css" href="./style.css" />
</head>
<body>
<div id="display"></div>
</body>
<script>

const transport = new TransportLayer();

class Entity extends UIElement {
  constructor(div, address) {
    super(div);
    this.stores = {
      fastmem: new Store(),
    };
    this.setAddress(address);
    this.setId(createUUID());
  }

  debug(tag, ...args) {
    args[0] = `${this.getAddress()} ${args[0]}`;
    debug(tag, ...args);
  }

  setId(id) { this.id = id; }
  getId() { return this.id; }

  getAddress() { return this.address };
  setAddress(address) {
    if (this.getAddress()) {
      throw new Error('address already set; changing addresses not currently supported');
    }
    this.address = address;
    // Register the address with transport layer
    this.debug('transport', `binding to address ${address}`);
    this.transport = transport.bind(this, address, msg => {
      // Dispatch message to appropriate handler
      return this.message(msg);
    });
    // As a side-effect, copy this to our label
    this.setLabel(`#${address}`);
  }

  getOffset() {
    return {
      left: this.getDiv().offsetLeft,
      top: this.getDiv().offsetTop,
      width: this.getDiv().offsetWidth,
      height: this.getDiv().offsetHeight,
    };
  }

  findAllOthers() {
    // How do we want to find other elements?
    // If a group of elements is started with a common purpose,
    // they can be equipped with a mechanism to message one another.
    // That could be enough to get us started.
    return transport.list().filter(x => x !== this.address);
  }

  avoidAllOthers() {
    // Move to avoid covering any other entity.
    const coveredAreas = {};
    this.findAllOthers().forEach(address => {
      const msg = {query: {var: 'offset'}};
      this.debug('positioning', `avoidAllOthers querying ${address}`);
      this.transport.send(address, msg, response => {
        const {left, top, width, height} = response.data;
        coveredAreas[address] = ({left, top, width, height});
      });
    });
    // Because of how we've implemented this, it's currently synchronous;
    // Really we'll need an `await` here.

    // Ok now we know where everyone else is.
    // First let's check whether we are overlapping with anyone.
    // That means, is anyone's corner in our space, or are any of our corners in their space?

    const overlappingAnyOthers = () => {
      const result = Object.values(coveredAreas).some(coveredArea => {
        return rectanglesIntersect(coveredArea, this.getOffset());
      });
      this.debug('positioning', `overlappingAnyOthers: ${result}`);
      return result;
    };

    const padding = 10;
    const targetSide = Math.random() > 0.5 ? 'left' : 'right';
    while (overlappingAnyOthers()) {
      switch (targetSide) {
        case 'right':
          this.debug('positioning', `moving to the rightmost side`);
          const rightmost = Object.values(coveredAreas).reduce((max, cur) => {
            const val = cur.left + cur.width;
            return Math.max(val, max);
          }, 0);
          this.getDiv().style.left = (rightmost + padding) + 'px';
          continue;
        case 'left':
          this.debug('positioning', `moving to the leftmost side`);
          const leftmost = Object.values(coveredAreas).reduce((min, cur) => {
            const val = cur.left;
            if (min === null) {
              return val;
            }
            return Math.min(val, min);
          }, null);
          // If there's room, just move to the left.
          // Otherwise, request all other entities to move to the right.
          const spaceAvailableLeft = this.getDiv().offsetLeft;
          if (spaceAvailableLeft > 0) {
            this.getDiv().style.left = (this.getDiv().offsetLeft - spaceAvailableLeft) + 'px';
          }
          const spaceAvailableRight = leftmost - this.getDiv().offsetLeft - this.getDiv().offsetWidth - padding;
          if (spaceAvailableRight < 0) {
            this.requestAllOthersToShift(-spaceAvailableRight, 0,
              response => {
                const address = response.header.src;
                const {left, top, width, height} = response.data;
                coveredAreas[address] = ({left, top, width, height});
              });
          }
          continue;
      }
    }

    // What could also be nice is to generate a map of uncovered spaces.
    // Then we could just pick a space from that list.

    // When we get to the point where we have filled up the available space we'll need to do something. Maybe we
    // minimize overlap instead of disallowing it completely. Maybe we shake things around to try to consolidate
    // smaller empty spaces into larger ones.

    // It could be useful to be able to expand in any direction. For example move everything to the right to
    // create more space on the left. [Implemented as requestOtherToShift() and requestAllOthersToShift().]

    // Another strategy we can try is we can do the following:
    // - decide where we want to be
    // - come up with proposed modifications to the positions of other entities
    // - request the other entities to move in the proposed ways
    // - occupy our new position

    // We can combine these approaches
    // Does this need to be recursive?
    // If so, can we provide any bounds for the stack depth? And/or do we have tail-call optimization?

    // Let's try a multi-pass approach.
    // First, look for nearby holes. We can do this via binary search along some vectors.
    // Maybe keep going until we find at least one hole; Maybe keep going longer (part of a separate routine probably)
    // as a means of mapping out the space, e.g. in preparation for trying to place multiple entities.
    // Once we do or do not find any nearby holes, next test a plan where we ask everyone to move directly away from
    // us. If we ask everyone to move along a particular vector, it's the same operation as moving ourselves combined
    // with effectively shifting the position of the origin.
    // If we however ask everyone to move along distinct vectors, this is potentially a very different kind of
    // operation. It can be designed according to any mapping we desire.
    // The other entities won't necessarily know


  }

  requestOtherToShift(address, left, top, callback) {
    const msg = {
      request: {
        shift: {left, top}
      },
      query: {
        var: 'offset'
      },
    };
    this.transport.send(address, msg, response => {
      callback(response);
    });
  }

  requestAllOthersToShift(left, top, callback) {
    this.findAllOthers().forEach(address => {
      this.requestOtherToShift(address, left, top, callback);
    });
  }

  askToBeConsidered(address) {
    const msg = {
      considerations: {
        [this.getId()]: {
          overlap: 'avoid',
          address: this.getId()
        },
      },
    };
    this.transport.send(address, msg);
  }

  learnConsideration(consideration) {
    this.considerations.push(consideration);

    // What structure do we expect here?
    // Generally, some expression or expressions we can evaluate.
    // I suppose it's really up to us to determine what kind of expressions we'll accept.
    // I think what we want to do is accept expressions of the following form:
    // (Condition, Effect). We'll evaluate conditions and try to keep track of the effects produced. Effects can cause conditions, so there may need to be some reevaluation as well.
    // We don't need to know all the possible conditions ahead of time, if we allow some kind of dynamic/forward
    // reference.
    // Sounds like a system that lets you write programs with side-effects.
    // Is there a functional way to write these instead?
    // What about "constraint" expressions?
    // Maybe each consideration articulates some invariant.
    // As follows:
    // (A condition is met; say an event has occurred)
    // (some duration has elapsed, more than a grace period but less than a timeout)
    // (we have performed some action in response to the event)
    //

    // State snapshotting and event streaming are powerful features.
    // I would like to implement them in this system I'm building here, if not now then soon-ish.
  }

  message(msg) {
    this.debug('messaging', `received message: ${JSON.stringify(msg)}`);
    if (msg.header.dst !== this.getAddress()) {
      throw new Error(`${this.getAddress()} received message destined for ${msg.header.dst}`);
    }
    // See if we can infer considerations from this message,
    // using what other context we have available, such as
    // from other messages, or other asynchronous processes.
    // If so, then do our best to learn the implied considerations.

    // How shall we go about this?
    // Let's start simple. We'll define a message schema to let people
    // tell us their considerations.
    // It can be in this form:
    // I care about the result of evaluating the following expression:
    //   < Expression that references any available operations we support >
    // We do the following:
    //   - Reference immediately available memory
    //   - Perform any necessary actions based on knowledge available at this time
    //   - Acknowledge receipt of request
    //   - Perform any further actions on behalf of this message
    //   - Perform any further actions on behalf of other considerations
    //   - Await further messages
    //   - Await other asynchronous events (or treat everything as a message)
    //   - Perform any further actions on behalf of these messages or other considerations

    if (msg.considerations) {
      Object.keys(msg.considerations).forEach(id => {
        if (!this.stores.fastmem.has('considerations', id)) {
          // First time we've seen this recently.
          // It's possible we have more information available if we make some queries.
          // We probably want to form a rank estimate, and form a plan of action.
          // It's possible that we could revise the plan in the future, and/or that the plan encodes some complexity
          // regarding how it will respond to future conditions.
          // Anyway, just go ahead and store it.
          this.stores.fastmem.set('considerations', id, msg.considerations[id]);
        }
        const c = this.stores.fastmem.get('considerations', id);
        this.debug('considerations', 'consideration:', c);
      });
    }

    if (msg.request) {
      if (msg.request.shift) {
        this.getDiv().style.left = (this.getDiv().offsetLeft + msg.request.shift.left) + 'px';
        this.getDiv().style.top = (this.getDiv().offsetTop + msg.request.shift.top) + 'px';
      }
    }

    if (msg.query) {
      // Let's use jsonLogic to evaluate this.
      // We'll explicitly expose here whatever content we want to make available.
      const context = {
        offset: this.getOffset(),
      };
      const result = jsonLogic.apply(msg.query, context);
      return result;
    }

    // If we haven't already replied, return true here as an ack
    return true;
  }
}

// Tests

{
  const point = {left: 1, top: 1};
  const rect = {left: 0, top: 0, width: 2, height: 2};
  const result = rectangleContainsPoint(rect, point);
  if (!result) {
    throw new Error('test failed');
  }
}

{
  const rect = {left: 0, top: 0, width: 2, height: 2};
  const result = getRectangleCorners(rect);
  if (result[0].left != 0 || result[0].top != 0 ||
    result[1].left != 0 || result[1].top != 2 ||
    result[2].left != 2 || result[2].top != 0 ||
    result[3].left != 2 || result[3].top != 2) {
    throw new Error('test failed');
  }
}

{
  const rect1 = {left: 0, top: 0, width: 20, height: 10};
  const rect2 = {left: 5, top: 0, width: 10, height: 10};
  const result = rectanglesIntersect(rect1, rect2);
  if (!result) {
    throw new Error('test failed');
  }
}

// Example

const display = document.getElementById('display');
function addElement(address) {
  const element = new Entity(null, address);
  display.append(element.getDiv());
  return element;
}
const x1 = addElement(1);
x1.setText('ONE');
const x2 = addElement(2);
x2.setText('TWO TWO');
const x3 = addElement(3);
x3.setText('THREE THREE THREE');
const x4 = addElement(4);
x4.setText('FOUR FOUR FOUR FOUR');

debug('transport', 'address list', transport.list());

x1.avoidAllOthers();
x2.avoidAllOthers();
x3.avoidAllOthers();
x4.avoidAllOthers();

debug('tags', listDebugTags().join(' '));

// x1.askToBeConsidered(x2.getAddress());

// Another strategy would be to form partnerships among entities, and have them use that to help them self-organize.

</script>
