<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
</head>
<body>
<div id="display"></div>
</body>
<script>

class UIElement {
  constructor(div, label) {
    this.children = [];

    if (div) {
      if (typeof div == 'string') {
        this.setDiv(document.getElementById(div));
      } else {
        this.setDiv(div);
      }
    } else {
      this.setDiv(document.createElement('div'));
    }

    // Helper to generate div wrappers
    const divWrap = (element, style) => {
      const wrapperDiv = document.createElement('div');
      wrapperDiv.append(element);
      Object.assign(wrapperDiv.style, style);
      return wrapperDiv;
    }

    // Let's have a div to wrap our own content
    this.headerDiv = document.createElement('div');
    this.headerDiv.style.position = 'relative';
    this.getDiv().append(this.headerDiv);

    // Let's show a label, if present
    this.labelP = document.createElement('p');
    Object.assign(this.labelP.style, {
      'font-size': '8pt',
      color: '#888888',
      position: 'absolute',
      // border: '1px red solid',
      top: '-2.5em',
      width: '20em',
    });
    this.headerDiv.append(this.labelP);
    if (label) {
      this.setLabel(label);
    }

    // Have a text value in addition to other possible children
    this.p = document.createElement('p');
    this.headerDiv.append(this.p);

    // Let's also have a div to wrap our children
    this.setChildrenDiv(document.createElement('div'));
    this.getChildrenDiv().style.position = 'relative';
    this.addDiv(this.getChildrenDiv());

    // To actually evaluate placements we may need some context.
    // I guess we can introspect our own bounding box.
    // We can also track changes of our children's properties, and
    // recompute layouts and/or notify children of the need to recompute.
    this.getDiv().style.position = 'absolute';
    this.getDiv().style.border = '1px #bbbbbb dotted';

    //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////

    // For now, establish conventions by defining some of our parameters here.
    this.conventions = {
      // gravityDirection: 'left',
    };
    // So far we have for each UIElement:
    // label, text, children
    // We will likely be adding more properties.
    // Think about how we want to support this: what kinds of properties do we need; what is the desired workflow for
    // adding them; how can we import/export elements (save/load, serialize/deserialize, marshall/unmarshall);
    // rendering; evaluating; referencing; indexing; etc.
    this.properties = {
      children: [],
      label: null,
      text: null,
      layoutProperties: null, // member of split group; position; etc.
    };
  }

  getChildrenDiv() {
    return this.childrenDiv;
  }

  setChildrenDiv(div) {
    this.childrenDiv = div;
  }

  getDiv() {
    return this.div;
  }

  setDiv(div) {
    this.div = div;
  }

  addDiv(div) {
    this.getDiv().append(div);
  }

  setText(text) {
    // Apply the update to the docElement
    this.p.innerText = text;
  }

  getText() {
    return this.p.innerText;
  }

  getLabel() {
    return this.label;
  }

  setLabel(label) {
    this.label = label;
    this.labelP.innerText = this.getLabel();
  }

  expandToWindow() {
    const margin = 50;
    this.getDiv().style.width = (window.innerWidth - 2 * margin) + 'px';
    this.getDiv().style.height = (window.innerHeight - 2 * margin) + 'px';
    this.getDiv().style.left = margin + 'px';
    this.getDiv().style.top = margin + 'px';
  }

  createChild() {
    // We want to return a handle like our own, but
    // initialized with the child as the root.
    // For now, the child will have no access to the parent;
    // it will be a one-way relationship.
    const child = new UIElement();
    child.getDiv().style.position = 'absolute';
    this.children.push(child);
    // Need to tie the DOM together as well
    this.getChildrenDiv().append(child.getDiv());
    return child;
  }


  createChildren(infoArray, configureChild) {
    return infoArray.map((info, index) => {
      return this.createChild();
    }).map((child, index, children) => {
      configureChild(child, index, children);
      return child;
    });
  }

  verticalSplit(infoArray) {
    let offset = 0;
    return this.createChildren(infoArray, (child, index, children) => {
      // We want this child to start where its predecessor ends
      child.getDiv().style.top = offset + 'px';
      child.getDiv().style.height = infoArray[index];
      child.getDiv().style.width = '100%';
      child.setLabel(`verticalSplit ${index}`);
      offset += child.getDiv().offsetHeight;
    });
  }

  horizontalSplit(infoArray) {
    let offset = 0;
    return this.createChildren(infoArray, (child, index, children) => {
      child.getDiv().style.left = offset + 'px';
      child.getDiv().style.width = infoArray[index];
      child.setLabel(`horizontalSplit ${index}`);
      offset += child.getDiv().offsetWidth;
    });
  }
}

// Example
const webPage = new UIElement('display', 'main');
webPage.expandToWindow();
const [titleBar, body] = webPage.verticalSplit(['10em', undefined]);
const columns = body.horizontalSplit(['30em', '30em', undefined]);
const rows2 = columns[1].verticalSplit(['20em', undefined]);

titleBar.setText('Title Bar');
body.setText('Body');
columns.map((col, idx) => {
  col.setText(`Column ${idx}`);
});
rows2.map((row, idx) => {
  row.setText(`Column 2 Row ${idx}`);
});

setTimeout(() => {
  body.setText(body.getText() + ' ...Hello!');
}, 2000);



// Let's support a grid layout system...
// That can be done by creating horizontal and vertical subdivisions, right?

// Also there are a couple more considerations to make for these UIElement boxes.
// How big do we want them?
// Not just shrinking to fit contents

</script>



